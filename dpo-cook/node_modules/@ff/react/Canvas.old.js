"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
/**
 * Component wrapping a HTML Canvas Element. Provides callbacks for creating/destroying the drawing context,
 * resizing and redrawing. Wraps the canvas in a div element for easier placement.
 */
class Canvas extends React.Component {
    constructor(props) {
        super(props);
        this.canvasRef = React.createRef();
        this.canvasContext = null;
        this.resize = this.resize.bind(this);
    }
    get element() {
        return this.canvasRef.current;
    }
    createContext2d(attribs /* Canvas2DContextAttributes */) {
        const canvasElement = this.canvasRef.current;
        if (canvasElement && !this.canvasContext) {
            return this.canvasContext = canvasElement.getContext("2d", attribs);
        }
    }
    createContext3d(attribs) {
        const canvasElement = this.canvasRef.current;
        if (canvasElement && !this.canvasContext) {
            return this.canvasContext = canvasElement.getContext("webgl", attribs);
        }
    }
    componentDidUpdate() {
        this.resize();
    }
    componentDidMount() {
        const { id, index, painter, onCreateContext } = this.props;
        if (painter) {
            painter.createContext(this);
        }
        else if (onCreateContext) {
            onCreateContext({ id, index, sender: this });
        }
        this.resize();
        window.addEventListener("resize", this.resize);
    }
    componentWillUnmount() {
        const { id, index, painter, onDestroyContext } = this.props;
        if (painter) {
            painter.destroyContext(this);
        }
        else if (onDestroyContext) {
            onDestroyContext({ id, index, sender: this });
        }
        window.removeEventListener("resize", this.resize);
    }
    render() {
        const style = Object.assign({}, Canvas.fullsizeStyle, this.props.style);
        return (React.createElement("div", { className: this.props.className, style: style },
            React.createElement("canvas", { style: Canvas.canvasStyle, ref: this.canvasRef })));
    }
    resize() {
        const canvasElement = this.canvasRef.current;
        if (!canvasElement) {
            return;
        }
        const resolution = this.props.resolution;
        const width = canvasElement.width = canvasElement.offsetWidth * resolution;
        const height = canvasElement.height = canvasElement.offsetHeight * resolution;
        const { id, index, painter, onResize } = this.props;
        if (painter) {
            painter.resize(width, height, resolution);
        }
        else if (onResize) {
            onResize({ width, height, resolution, id, index, sender: this });
        }
    }
}
exports.default = Canvas;
Canvas.defaultProps = {
    className: "ff-canvas",
    resolution: 1
};
Canvas.canvasStyle = {
    display: "block",
    width: "100%",
    height: "100%"
};
Canvas.fullsizeStyle = {
    position: "absolute",
    top: 0, right: 0, bottom: 0, left: 0
};
//# sourceMappingURL=Canvas.old.js.map