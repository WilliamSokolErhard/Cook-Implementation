"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const Draggable_1 = require("./Draggable");
const Color_1 = require("@ff/core/Color");
class Dial extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: props.value
        };
        this.canvasElement = null;
        this.canvasContext = null;
        this.onRef = this.onRef.bind(this);
        this.onRefWheel = this.onRefWheel.bind(this);
        this.onDragBegin = this.onDragBegin.bind(this);
        this.onDragMove = this.onDragMove.bind(this);
        this.onDragEnd = this.onDragEnd.bind(this);
    }
    setValue(value) {
        const props = this.props;
        value = Math.round(value / props.step) * props.step;
        value = value < props.min ? props.min : (value > props.max ? props.max : value);
        this.setState({ value });
        if (this.props.onChange) {
            this.props.onChange(value, this.isDragging);
        }
    }
    componentDidMount() {
        this.redraw();
    }
    componentDidUpdate() {
        this.redraw();
    }
    render() {
        const props = this.props;
        let style = {
            position: "relative",
            width: props.size
        };
        let canvasStyle = {
            display: "block"
        };
        let labelStyle = {
            display: "block",
            position: "absolute",
            top: props.type === "gauge" ? "-3%" : 0,
            left: 0, right: 0, bottom: 0,
            textAlign: "center",
            lineHeight: props.size
        };
        if (props.fontSize) {
            labelStyle.fontSize = props.fontSize.toString();
        }
        let value = this.state.value;
        let text = props.percent
            ? (value * 100).toFixed(props.precision) + "%"
            : value.toFixed(props.precision);
        return (React.createElement("div", { className: props.className, style: style },
            React.createElement(Draggable_1.default, { onDragBegin: this.onDragBegin, onDragMove: this.onDragMove, onDragEnd: this.onDragEnd },
                React.createElement("canvas", { ref: this.onRef, style: canvasStyle, width: props.size, height: props.size }),
                React.createElement("label", { className: "ff-label", style: labelStyle }, text),
                React.createElement("div", { ref: this.onRefWheel, className: "ff-wheel", style: { display: "none" } }))));
    }
    onRef(element) {
        this.canvasElement = element;
        this.canvasContext = element ? element.getContext("2d") : null;
    }
    onRefWheel(element) {
        if (element) {
            // calculate colors
            const computedStyle = window.getComputedStyle(element);
            this.bgColor = new Color_1.default(computedStyle.backgroundColor);
            this.fgColor = new Color_1.default(computedStyle.color);
            if (this.props.ghost) {
                this.bgActiveColor = this.bgColor.clone().inverseMultiply(0.1).setAlpha(0.8);
                this.fgActiveColor = this.fgColor.clone().setAlpha(0.8);
            }
        }
    }
    onDragBegin(event) {
        this.startValue = this.state.value;
        this.revolutions = 0;
        this.fraction = this.angleToFraction(this.getAngle(event), false);
        this.isDragging = true;
    }
    onDragMove(event) {
        let props = this.props;
        let fraction = this.angleToFraction(this.getAngle(event), true);
        this.setValue(fraction * (props.max - props.min) + props.min);
    }
    onDragEnd(event) {
        this.isDragging = false;
        let props = this.props;
        let fraction = this.angleToFraction(this.getAngle(event), true);
        this.setValue(fraction * (props.max - props.min) + props.min);
    }
    redraw() {
        let props = this.props;
        let canvas = this.canvasElement;
        let context = this.canvasContext;
        const size = canvas.width;
        const halfSize = size * 0.5;
        let thickness = props.thickness;
        let ringSize = size * 0.2;
        if (typeof thickness === "number") {
            ringSize = props.thickness;
        }
        else if (typeof thickness === "string"
            && thickness.endsWith("%")) {
            ringSize = Number.parseFloat(thickness) * size * 0.5 * 0.01;
        }
        else {
            ringSize = Number.parseFloat(thickness);
        }
        context.clearRect(0, 0, size, size);
        let drawGhost = props.ghost && this.isDragging;
        let value = drawGhost ? this.startValue : this.state.value;
        let angleZero = this.valueToAngle(props.min);
        let angleOne = this.valueToAngle(props.max);
        let angleValue = this.valueToAngle(value);
        this.drawSegment(this.bgColor.toString(), halfSize, ringSize, angleValue, angleOne);
        this.drawSegment(this.fgColor.toString(), halfSize, ringSize, angleZero, angleValue);
        // ring drag overlay
        if (drawGhost) {
            angleValue = this.valueToAngle(this.state.value);
            this.drawSegment(this.bgActiveColor.toString(), halfSize, ringSize, angleValue, angleOne);
            this.drawSegment(this.fgActiveColor.toString(), halfSize, ringSize, angleZero, angleValue);
        }
    }
    drawSegment(color, radius, ringSize, startAngle, endAngle) {
        let context = this.canvasContext;
        context.fillStyle = color;
        context.beginPath();
        context.arc(radius, radius, radius, startAngle, endAngle, false);
        context.arc(radius, radius, radius - ringSize, endAngle, startAngle, true);
        context.fill();
    }
    getAngle(event) {
        let rect = this.canvasElement.getBoundingClientRect();
        let x = event.clientX - (rect.left + rect.right) * 0.5;
        let y = event.clientY - (rect.top + rect.bottom) * 0.5;
        return Math.atan2(y, x);
    }
    angleToFraction(angle, update = true) {
        let props = this.props;
        let isGauge = props.type === "gauge";
        let fraction = angle / Math.PI * 0.5;
        fraction = fraction + (isGauge ? -0.25 : 0.25);
        fraction = (fraction < 0 ? fraction + 1 : fraction);
        let prevFraction = this.fraction;
        this.fraction = fraction;
        if (update) {
            if (prevFraction > 0.75 && fraction < 0.25) {
                this.revolutions++;
            }
            else if (prevFraction < 0.25 && fraction > 0.75) {
                this.revolutions--;
            }
            if (props.overflow !== "wrap" || isGauge) {
                fraction += this.revolutions;
            }
        }
        if (isGauge) {
            fraction = (fraction - 0.125) / 0.75;
        }
        return fraction < 0 ? 0 : (fraction > 1 ? 1 : fraction);
    }
    valueToAngle(value) {
        let doublePi = Math.PI * 2;
        let props = this.props;
        value = (value - props.min) / (props.max - props.min);
        if (props.type === "gauge") {
            return (value * 0.75 - 0.625) * doublePi;
        }
        else {
            return (value - 0.25) * doublePi;
        }
    }
}
exports.default = Dial;
Dial.defaultProps = {
    className: "ff-dial",
    size: "200px",
    thickness: "25%",
    ghost: false,
    type: "rotary",
    meter: "right",
    overflow: "limit",
    min: 0,
    max: 1,
    step: 0.01,
    precision: 2,
    percent: false,
    value: 0
};
//# sourceMappingURL=Dial.js.map