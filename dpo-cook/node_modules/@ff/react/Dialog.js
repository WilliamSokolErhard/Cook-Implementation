"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const ReactDOM = require("react-dom");
class Anchor extends React.Component {
    render() {
        const child = React.Children.only(this.props.children);
        return React.cloneElement(child, { ref: this.props.elementRef });
    }
}
exports.Anchor = Anchor;
/**
 * Provides a freely placeable dialog container. The dialog can be displayed modal or non-modal.
 * An event reports when the user clicks outside of the dialog area.
 */
class Dialog extends React.Component {
    constructor(props) {
        super(props);
        this.onRefAnchor = this.onRefAnchor.bind(this);
        this.onRefDialog = this.onRefDialog.bind(this);
        this.onRefModalPlane = this.onRefModalPlane.bind(this);
        this.onModalPlaneDown = this.onModalPlaneDown.bind(this);
        this.onModalPlaneKeyPress = this.onModalPlaneKeyPress.bind(this);
        this.calculateLayout = this.calculateLayout.bind(this);
        this.dialogElement = null;
        this.anchorElement = null;
        this.modalElement = null;
        this.portalElement = null;
        // create a dom element serving as attachment point for the dialog element.
        this.parentElement = document.createElement("div");
    }
    componentDidMount() {
        // append the dialog's parent element to the dom
        document.body.appendChild(this.parentElement);
        // start listening for resize events in order to update the layout
        window.addEventListener("resize", this.calculateLayout);
        if (this.props.portal) {
            const portalElement = ReactDOM.findDOMNode(this.props.portal);
            if (portalElement instanceof HTMLElement) {
                this.portalElement = portalElement;
            }
        }
    }
    componentDidUpdate() {
        this.calculateLayout();
    }
    componentWillUnmount() {
        // remove the dialog's parent element from the dom
        document.body.removeChild(this.parentElement);
        // stop listening for resize events
        window.removeEventListener("resize", this.calculateLayout);
        this.portalElement = null;
        this.anchorElement = null;
    }
    render() {
        const { className, style, visible, modal, children } = this.props;
        const styles = Object.assign({}, Dialog.style, style);
        // if an anchor component is provided, it must be first in list of children
        const childArray = React.Children.toArray(children);
        let anchorChild = null;
        let dialogChildren = childArray;
        if (childArray.length > 0 && childArray[0]["type"] === Anchor) {
            anchorChild = React.cloneElement(childArray[0], { elementRef: this.onRefAnchor });
            dialogChildren = childArray.slice(1);
        }
        let dialog = null;
        if (visible) {
            const dialogFrame = React.createElement("div", {
                ref: this.onRefDialog,
                className,
                style: styles
            }, dialogChildren);
            dialog = modal ? React.createElement("div", {
                ref: this.onRefModalPlane,
                className: className + "ff-modal",
                style: Dialog.modalStyle,
                "touch-action": "none",
                onPointerDown: this.onModalPlaneDown,
                onKeyUp: this.onModalPlaneKeyPress
            }, dialogFrame) : dialogFrame;
        }
        const dialogPortal = visible ? ReactDOM.createPortal(dialog, this.parentElement) : null;
        return (React.createElement(React.Fragment, null,
            anchorChild,
            dialogPortal));
    }
    onRefAnchor(component) {
        if (component) {
            const anchorElement = ReactDOM.findDOMNode(component);
            if (anchorElement instanceof HTMLElement) {
                this.anchorElement = anchorElement;
            }
        }
        else {
            this.anchorElement = null;
        }
    }
    onRefDialog(element) {
        this.dialogElement = element;
    }
    onRefModalPlane(element) {
        this.modalElement = element;
    }
    onModalPlaneDown(event) {
        // if event is bubbling from dialog, do nothing
        if (event.target !== this.modalElement) {
            return;
        }
        const { id, index, onTapModal } = this.props;
        // report tap on modal plane
        if (onTapModal) {
            onTapModal({ id, index, sender: this });
        }
        //event.preventDefault();
    }
    onModalPlaneKeyPress(event) {
        const { id, index, onTapModal } = this.props;
        // if escape key pressed
        if (event.keyCode === 27 && onTapModal) {
            // report tap on modal plane
            onTapModal({ id, index, sender: this });
        }
    }
    calculateLayout() {
        const dialogElement = this.dialogElement;
        if (!dialogElement) {
            return;
        }
        const dialogRect = dialogElement.getBoundingClientRect();
        let { anchor, justify, align } = this.props;
        let dialogX = 0;
        let dialogY = 0;
        const dlgOffsetX = justify === "start" ? 0 : (justify === "end" ? dialogRect.width : dialogRect.width * 0.5);
        const dlgOffsetY = align === "start" ? 0 : (align === "end" ? dialogRect.height : dialogRect.height * 0.5);
        if (this.anchorElement) {
            const anchorRect = this.anchorElement.getBoundingClientRect();
            let anchorOffsetX = 0;
            let anchorOffsetY = 0;
            if (!justify) {
                justify = anchor === "left" ? "start" : (anchor === "right" ? "start" : "center");
            }
            if (!align) {
                align = anchor === "top" ? "start" : (anchor === "bottom" ? "start" : "center");
            }
            switch (justify) {
                case "start":
                    anchorOffsetX = 0;
                    break;
                case "end":
                    anchorOffsetX = anchorRect.width;
                    break;
                case "center":
                    anchorOffsetX = anchorRect.width * 0.5;
                    break;
            }
            switch (align) {
                case "start":
                    anchorOffsetY = 0;
                    break;
                case "end":
                    anchorOffsetY = anchorRect.height;
                    break;
                case "center":
                    anchorOffsetY = anchorRect.height * 0.5;
                    break;
            }
            switch (anchor) {
                case "left":
                    dialogX = anchorRect.left - dialogRect.width;
                    dialogY = anchorRect.top + anchorOffsetY - dlgOffsetY;
                    break;
                case "right":
                    dialogX = anchorRect.right;
                    dialogY = anchorRect.top + anchorOffsetY - dlgOffsetY;
                    break;
                case "top":
                    dialogX = anchorRect.left + anchorOffsetX - dlgOffsetX;
                    dialogY = anchorRect.top - dialogRect.height;
                    break;
                case "bottom":
                    dialogX = anchorRect.left + anchorOffsetX - dlgOffsetX;
                    dialogY = anchorRect.bottom;
            }
        }
        else {
            switch (justify) {
                case "start":
                    dialogX = 0;
                    break;
                case "end":
                    dialogX = window.innerWidth - dialogRect.width;
                    break;
                default:
                    dialogX = (window.innerWidth - dialogRect.width) * 0.5;
                    break;
            }
            switch (align) {
                case "start":
                    dialogY = 0;
                    break;
                case "end":
                    dialogY = window.innerHeight - dialogRect.height;
                    break;
                default:
                    dialogY = (window.innerHeight - dialogRect.height) * 0.5;
                    break;
            }
        }
        // keep inside portal element
        if (this.portalElement) {
            const portalRect = this.portalElement.getBoundingClientRect();
            dialogX = Math.max(portalRect.left, dialogX);
            dialogX = Math.min(portalRect.right - dialogRect.width, dialogX);
            dialogY = Math.max(portalRect.top, dialogY);
            dialogY = Math.min(portalRect.bottom - dialogRect.height, dialogY);
        }
        dialogElement.style.left = dialogX + "px";
        dialogElement.style.top = dialogY + "px";
    }
}
exports.default = Dialog;
Dialog.defaultProps = {
    className: "ff-dialog"
};
Dialog.style = {
    position: "absolute",
    zIndex: 1000
};
Dialog.modalStyle = {
    position: "absolute",
    top: 0, left: 0, right: 0, bottom: 0,
    zIndex: 1000,
    touchAction: "none"
};
//# sourceMappingURL=Dialog.js.map