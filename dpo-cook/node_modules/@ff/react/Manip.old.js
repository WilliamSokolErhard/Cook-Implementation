"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const math_1 = require("@ff/core/math");
class Manip extends React.Component {
    constructor(props) {
        super(props);
        this.element = React.createRef();
        this.isActive = false;
        this.activePointers = {};
        this.centerX = 0;
        this.centerY = 0;
        this.primaryX = 0;
        this.primaryY = 0;
        this.pinchStartDistance = 0;
        this.pinchLastDistance = 0;
        this.pinchLastAngle = 0;
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onPointerCancel = this.onPointerCancel.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
    }
    render() {
        const { className, style, children } = this.props;
        const props = {
            className,
            style,
            ref: this.element,
            "touch-action": "none",
            onPointerDown: this.onPointerDown,
            onPointerMove: this.onPointerMove,
            onPointerUp: this.onPointerUp,
            onPointerCancel: this.onPointerCancel,
            onWheel: this.onMouseWheel,
            onDoubleClick: this.onDoubleClick,
            onContextMenu: this.onContextMenu
        };
        return React.createElement("div", props, children);
    }
    onPointerDown(event) {
        this.activePointers[event.pointerId] = event;
        if (this.props.capture) {
            this.element.current.setPointerCapture(event.pointerId);
        }
        const manipEvent = this.createManipFromPointerEvent(event, "down");
        if (event.isPrimary) {
            this.isActive = true;
            this.sendManipBeginEvent(manipEvent);
        }
        else {
            this.sendManipUpdateEvent(manipEvent);
        }
    }
    onPointerMove(event) {
        this.activePointers[event.pointerId] = event;
        const manipEvent = this.createManipFromPointerEvent(event, "move");
        this.sendManipUpdateEvent(manipEvent);
    }
    onPointerUp(event) {
        delete this.activePointers[event.pointerId];
        this.onPointerUpOrCancel(event);
    }
    onPointerCancel(event) {
        delete this.activePointers[event.pointerId];
        this.onPointerUpOrCancel(event);
    }
    onPointerUpOrCancel(event) {
        const manipEvent = this.createManipFromPointerEvent(event, "up");
        if (event.isPrimary) {
            this.isActive = false;
            this.pinchStartDistance = 0;
            this.pinchLastDistance = 0;
            this.pinchLastAngle = 0;
            this.sendManipEndEvent(manipEvent);
        }
        else {
            this.sendManipUpdateEvent(manipEvent);
        }
    }
    onDoubleClick(event) {
        const manipEvent = this.createManipFromMouseEvent(event, "dblclick");
        const props = this.props;
        if (props.onManipEvent) {
            props.onManipEvent(manipEvent);
        }
        if (props.listener) {
            props.listener.onManipEvent(manipEvent);
        }
    }
    onContextMenu(event) {
        const manipEvent = this.createManipFromMouseEvent(event, "contextmenu");
        const props = this.props;
        let isHandled = false;
        if (props.onManipEvent) {
            isHandled = props.onManipEvent(manipEvent) || isHandled;
        }
        if (props.listener) {
            isHandled = props.listener.onManipEvent(manipEvent) || isHandled;
        }
        if (isHandled) {
            event.preventDefault();
        }
    }
    onMouseWheel(event) {
        const manipEvent = this.createManipFromMouseEvent(event, "wheel");
        manipEvent.wheel = event.deltaY;
        const props = this.props;
        if (props.onManipEvent) {
            props.onManipEvent(manipEvent);
        }
        if (props.listener) {
            props.listener.onManipEvent(manipEvent);
        }
    }
    sendManipBeginEvent(event) {
        event.isActive = true;
        const props = this.props;
        if (props.onManipBegin) {
            props.onManipBegin(event);
        }
        if (props.listener) {
            props.listener.onManipBegin(event);
        }
    }
    sendManipUpdateEvent(event) {
        event.isActive = this.isActive;
        const props = this.props;
        if (props.onManipUpdate) {
            props.onManipUpdate(event);
        }
        if (props.listener) {
            props.listener.onManipUpdate(event);
        }
    }
    sendManipEndEvent(event) {
        event.isActive = false;
        const props = this.props;
        if (props.onManipEnd) {
            props.onManipEnd(event);
        }
        if (props.listener) {
            props.listener.onManipEnd(event);
        }
    }
    createManipFromPointerEvent(event, type) {
        if (event.isPrimary) {
            this.primaryX = event.clientX;
            this.primaryY = event.clientY;
        }
        // calculate center and movement
        let centerX = 0;
        let centerY = 0;
        let pointerCount = 0;
        let pointerList = [];
        for (let id in this.activePointers) {
            const pointer = this.activePointers[id];
            pointerList.push(pointer);
            pointerCount++;
            centerX += pointer.clientX;
            centerY += pointer.clientY;
        }
        centerX /= pointerCount;
        centerY /= pointerCount;
        let movementX = centerX - this.centerX;
        let movementY = centerY - this.centerY;
        if (type === "down" || type === "up") {
            movementX = 0;
            movementY = 0;
        }
        this.centerX = centerX;
        this.centerY = centerY;
        // calculate pinch parameters
        let pinchDistance = 0;
        let pinchFactor = 1;
        let pinchAngle = 0;
        let pinchDeltaFactor = 1;
        let pinchDeltaAngle = 0;
        if (pointerCount === 2) {
            const dx = pointerList[1].clientX - pointerList[0].clientX;
            const dy = pointerList[1].clientY - pointerList[0].clientY;
            pinchDistance = Math.sqrt(dx * dx + dy * dy);
            if (this.pinchStartDistance === 0) {
                this.pinchStartDistance = pinchDistance;
            }
            pinchFactor = pinchDistance / this.pinchStartDistance;
            pinchDeltaFactor = this.pinchLastDistance > 0 ? (pinchDistance / this.pinchLastDistance) : 1;
            this.pinchLastDistance = pinchDistance;
            pinchAngle = Math.atan2(dy, dx);
            pinchDeltaAngle = this.pinchLastAngle !== 0
                ? math_1.default.deltaRadians(this.pinchLastAngle, pinchAngle) : 0;
            this.pinchLastAngle = pinchAngle;
        }
        return {
            id: this.props.id,
            index: this.props.index,
            sender: this,
            pointerEvent: event,
            originalEvent: event,
            target: event.target,
            activePointerList: pointerList,
            activePointerCount: pointerCount,
            type,
            isActive: false,
            movementX,
            movementY,
            centerX,
            centerY,
            primaryX: this.primaryX,
            primaryY: this.primaryY,
            pinchDistance,
            pinchFactor,
            pinchDeltaFactor,
            pinchAngle,
            pinchDeltaAngle,
            wheel: 0
        };
    }
    createManipFromMouseEvent(event, type) {
        return {
            id: this.props.id,
            index: this.props.index,
            sender: this,
            pointerEvent: null,
            originalEvent: event,
            target: event.target,
            activePointerList: null,
            activePointerCount: null,
            type,
            isActive: false,
            movementX: 0,
            movementY: 0,
            centerX: 0,
            centerY: 0,
            primaryX: 0,
            primaryY: 0,
            pinchDistance: 1,
            pinchFactor: 1,
            pinchDeltaFactor: 1,
            pinchAngle: 0,
            pinchDeltaAngle: 0,
            wheel: 0
        };
    }
}
exports.default = Manip;
Manip.defaultProps = {
    className: "ff-manip"
};
//# sourceMappingURL=Manip.old.js.map