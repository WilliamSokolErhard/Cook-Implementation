"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const Draggable_1 = require("./Draggable");
class FieldEdit extends React.Component {
    constructor(props) {
        let value = props.value;
        let format = props.format;
        if (value === undefined) {
            value = format ? (format.preset || 0) : 0;
        }
        if (format === undefined) {
            format = {
                type: typeof props.value
            };
        }
        super(props);
        this.state = {
            value: value,
            format: format,
            isDragging: false,
            isEditing: false
        };
        this.inputElement = null;
        this.startValue = undefined;
        this.onTap = this.onTap.bind(this);
        this.onDragBegin = this.onDragBegin.bind(this);
        this.onDragMove = this.onDragMove.bind(this);
        this.onDragEnd = this.onDragEnd.bind(this);
        this.onInputKeyDown = this.onInputKeyDown.bind(this);
        this.onInputChange = this.onInputChange.bind(this);
        this.onBlur = this.onBlur.bind(this);
    }
    render() {
        const { className, style } = this.props;
        const { format, isDragging, isEditing } = this.state;
        const classes = className + (isDragging ? " ff-dragging" : "");
        const textStyle = FieldEdit.textStyle;
        let barStyle = {
            width: `${this.getBarWidthPercent()}%`
        };
        return (React.createElement(Draggable_1.default, { className: classes, style: style, draggable: !isEditing && format.type === "number", onTap: this.onTap, onDragBegin: this.onDragBegin, onDragMove: this.onDragMove, onDragEnd: this.onDragEnd },
            format.bar ? React.createElement("div", { className: "ff-bar", style: barStyle }) : null,
            React.createElement("label", { className: "ff-text ff-align-right", style: textStyle }, this.getFormattedValue()),
            isEditing ? React.createElement("form", null,
                React.createElement("input", { className: "ff-edit ff-align-right", type: "text", defaultValue: this.getFormattedValue(), ref: el => this.setInputRef(el), onKeyDown: this.onInputKeyDown, onChange: this.onInputChange, onBlur: this.onBlur })) : null));
    }
    setValue(value) {
        this.setState({ value: value });
        const { id, index, onChange, onCommit } = this.props;
        if (onChange) {
            onChange({ value, id, index, sender: this });
        }
        if (onCommit) {
            onCommit({ value, id, index, sender: this });
        }
    }
    incrementValue(delta) {
        this.setState(prevState => {
            const value = this.checkBounds(prevState.value + delta);
            const { id, index, onChange } = this.props;
            if (onChange) {
                onChange({ value, id, index, sender: this });
            }
            return { value };
        });
    }
    onDragBegin() {
        this.setState({ isDragging: true });
        this.startValue = this.state.value;
    }
    onDragMove(event, dx, dy) {
        const format = this.state.format;
        const delta = Math.abs(dx) > Math.abs(dy) ? dx : -dy;
        const multiplier = event.shiftKey ? 10 : (event.ctrlKey ? 0.1 : 1);
        let increment = delta * multiplier * (format.step || (format.percent ? 0.002 : 0.02));
        this.incrementValue(increment);
    }
    onDragEnd() {
        this.setValue(this.state.value);
        this.setState({ isDragging: false });
    }
    onTap() {
        const format = this.state.format;
        const type = format.type;
        if (type === "boolean") {
            this.setValue(!this.state.value);
        }
        else if (type === "number" || type === "string") {
            if (format.options) {
            }
            else {
                this.startEditing();
            }
        }
    }
    setInputRef(element) {
        this.inputElement = element;
        if (element) {
            element.focus();
            element.setSelectionRange(0, element.value.length);
        }
    }
    onInputKeyDown(event) {
        switch (event.key) {
            case "Enter":
                this.stopEditing(true);
                break;
            case "Escape":
                this.stopEditing(false);
                break;
        }
    }
    onBlur() {
        this.stopEditing(true);
    }
    onInputChange() {
    }
    startEditing() {
        this.setState({ isEditing: true });
    }
    stopEditing(readValue) {
        this.setState({ isEditing: false });
        if (readValue) {
            const format = this.state.format;
            const text = this.inputElement.value;
            let value;
            switch (format.type) {
                case "number":
                    value = parseFloat(text);
                    if (isNaN(value)) {
                        return;
                    }
                    value = this.checkBounds(value);
                    break;
                case "string":
                    value = text;
            }
            this.setValue(value);
        }
    }
    checkBounds(value) {
        const format = this.state.format;
        const min = typeof format.min === "number" ? format.min : -Number.MAX_VALUE;
        const max = typeof format.max === "number" ? format.max : Number.MAX_VALUE;
        return value > max ? max : (value < min ? min : value);
    }
    getFormattedValue() {
        const format = this.state.format;
        let value = this.state.value;
        let text = "";
        switch (format.type) {
            case "number":
                if (format.options) {
                    const last = format.options.length - 1;
                    value = value < 0 ? 0 : (value > last ? last : Math.trunc(value));
                    text = format.options[value];
                }
                else if (format.percent) {
                    value *= 100;
                    text = value.toFixed(format.precision || 0) + " %";
                }
                else {
                    text = value.toFixed(format.precision || 2);
                }
                break;
            case "boolean":
                text = value ? "true" : "false";
                break;
            case "string":
                text = "" + value;
                break;
            case "object":
                text = "[object]";
                break;
        }
        return text;
    }
    getBarWidthPercent() {
        const format = this.state.format;
        if (typeof format.min !== "number" || typeof format.max !== "number") {
            return 0;
        }
        return (this.state.value - format.min) / (format.max - format.min) * 100;
    }
}
exports.default = FieldEdit;
FieldEdit.defaultProps = {
    className: "ff-control ff-property-field"
};
FieldEdit.textStyle = {
    pointerEvents: "none",
    userSelect: "none",
    display: "block"
};
FieldEdit.Float = {
    type: "number",
    preset: 0,
    step: 0.01,
    precision: 3
};
FieldEdit.Integer = {
    type: "number",
    preset: 0,
    step: 0.1,
    precision: 0
};
FieldEdit.String = {
    type: "string",
    preset: "",
};
FieldEdit.Color = {
    type: "color",
    preset: [0, 0, 0]
};
//# sourceMappingURL=FieldEdit.js.map