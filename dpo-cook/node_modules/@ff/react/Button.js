"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
////////////////////////////////////////////////////////////////////////////////
/**
 * Universal button component based on pointer events. Works with mouse and touch input.
 * Provides an icon with support for Font Awesome icons and/or a text.
 *
 * Default classes applied to outer div: control, button, selected. Classes applied
 * to content span elements: content icon|text|image
 */
class Button extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            selected: props.selected
        };
        this.elementRef = React.createRef();
        this.pointerId = -1;
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onPointerCancel = this.onPointerCancel.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
    }
    setFocus() {
        if (this.elementRef.current) {
            this.elementRef.current.focus();
        }
    }
    isSelected() {
        return this.state.selected;
    }
    componentDidMount() {
        if (this.props.focused && this.elementRef.current) {
            this.elementRef.current.focus();
        }
    }
    render() {
        const { className, style, text, icon, faIcon, image, title, disabled, children } = this.props;
        const classes = className +
            (this.state.selected ? " ff-selected" : "") +
            (disabled === true ? " ff-disabled" : "");
        const mainStyle = Object.assign({}, Button.mainStyle, style);
        const contentStyle = Button.contentStyle;
        const props = {
            ref: this.elementRef,
            className: classes,
            style: mainStyle,
            title: title,
            tabIndex: 0,
            "touch-action": "none",
            onPointerDown: disabled ? null : this.onPointerDown,
            onPointerUp: disabled ? null : this.onPointerUp,
            onPointerCancel: disabled ? null : this.onPointerCancel,
            onKeyDown: disabled ? null : this.onKeyDown,
            onKeyUp: disabled ? null : this.onKeyUp
        };
        return (React.createElement("div", Object.assign({}, props),
            icon ? React.createElement("span", { className: "ff-content ff-icon " + icon, style: contentStyle }) : null,
            faIcon ? React.createElement("span", { className: "ff-content ff-icon fa fas fa-" + faIcon, style: contentStyle }) : null,
            image ? React.createElement("img", { className: "ff-content ff-image", src: image, style: contentStyle }) : null,
            text ? React.createElement("span", { className: "ff-content ff-text", style: contentStyle }, text) : null,
            children));
    }
    componentWillReceiveProps(nextProps) {
        this.setState({
            selected: nextProps.selected
        });
    }
    onPointerDown(event) {
        if (this.pointerId === -1) {
            this.pointerId = event.pointerId;
            const { id, index, onDown } = this.props;
            if (onDown) {
                onDown({ id, index, sender: this });
            }
        }
        event.stopPropagation();
    }
    onPointerUp(event) {
        if (this.pointerId === event.pointerId) {
            this.pointerId = -1;
            const { id, index, selectable, onSelect, onUp, onTap } = this.props;
            if (selectable) {
                this.setState(prevState => {
                    const selected = !prevState.selected;
                    if (onSelect) {
                        onSelect({ selected, id, index, sender: this });
                    }
                    return { selected };
                });
            }
            if (onUp) {
                onUp({ id, index, sender: this });
            }
            if (onTap) {
                onTap({ id, index, sender: this });
            }
        }
        event.stopPropagation();
    }
    onPointerCancel(event) {
        if (this.pointerId === event.pointerId) {
            this.pointerId = -1;
            const { id, index, onUp } = this.props;
            if (onUp) {
                onUp({ id, index, sender: this });
            }
        }
    }
    onKeyDown(event) {
        if (event.keyCode === 32) {
            const { id, index, onDown } = this.props;
            if (onDown) {
                onDown({ id, index, sender: this });
            }
        }
    }
    onKeyUp(event) {
        if (event.keyCode === 32) {
            const { id, index, selectable, onSelect, onUp, onTap } = this.props;
            if (selectable) {
                this.setState(prevState => {
                    const selected = !prevState.selected;
                    if (onSelect) {
                        onSelect({ selected, id, index, sender: this });
                    }
                    return { selected };
                });
            }
            if (onUp) {
                onUp({ id, index, sender: this });
            }
            if (onTap) {
                onTap({ id, index, sender: this });
            }
        }
    }
}
exports.default = Button;
Button.defaultProps = {
    className: "ff-control ff-button"
};
Button.mainStyle = {
    touchAction: "none",
    cursor: "pointer"
};
Button.contentStyle = {
    pointerEvents: "none",
    userSelect: "none"
};
//# sourceMappingURL=Button.js.map