"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const _verbose = false;
class Pointable extends React.Component {
    constructor(props) {
        super(props);
        this.element = null;
        this.capturePointer = false;
        this._activePointers = {};
        //this.onRef = this.onRef.bind(this);
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onPointerCancel = this.onPointerCancel.bind(this);
        this.onPointerEnter = this.onPointerEnter.bind(this);
        this.onPointerLeave = this.onPointerLeave.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
    }
    get activePointers() {
        return this._activePointers;
    }
    get activePointerList() {
        const pointers = this._activePointers;
        const pointerList = [];
        for (const key in pointers) {
            pointerList.push(pointers[key]);
        }
        return pointerList;
    }
    get activePointerCount() {
        return Object.keys(this._activePointers).length;
    }
    render() {
        const { className, style, children } = this.props;
        const props = {
            className,
            style,
            //ref: this.onRef,
            "touch-action": "none",
            onPointerDown: this.onPointerDown,
            onPointerMove: this.onPointerMove,
            onPointerUp: this.onPointerUp,
            onPointerCancel: this.onPointerCancel,
            onPointerEnter: this.onPointerEnter,
            onPointerLeave: this.onPointerLeave,
            onDoubleClick: this.onDoubleClick,
            onContextMenu: this.onContextMenu
        };
        return (React.createElement("div", Object.assign({}, props), children));
    }
    /*    protected onRef(element: HTMLDivElement)
        {
            const prevElement = this.element;
            this.element = element;
    
            if (element) {
                element.addEventListener("pointerdown", this.onPointerDown);
                element.addEventListener("pointermove", this.onPointerMove);
                element.addEventListener("pointerup", this.onPointerUp);
                element.addEventListener("pointercancel", this.onPointerCancel);
                element.addEventListener("pointerenter", this.onPointerEnter);
                element.addEventListener("pointerleave", this.onPointerLeave);
            }
            else if (prevElement) {
                prevElement.removeEventListener("pointerdown", this.onPointerDown);
                prevElement.removeEventListener("pointermove", this.onPointerMove);
                prevElement.removeEventListener("pointerup", this.onPointerUp);
                prevElement.removeEventListener("pointercancel", this.onPointerCancel);
                prevElement.removeEventListener("pointerenter", this.onPointerEnter);
                prevElement.removeEventListener("pointerleave", this.onPointerLeave);
            }
        }*/
    onPointerDown(event) {
        this._activePointers[event.pointerId] = event;
        const props = this.props;
        if (props.capture || this.capturePointer) {
            this.element.setPointerCapture(event.pointerId);
        }
        if (props.onPointerDown) {
            props.onPointerDown(event);
        }
        _verbose && console.log("onPointerDown", event);
    }
    onPointerMove(event) {
        this._activePointers[event.pointerId] = event;
        const props = this.props;
        if (props.onPointerMove) {
            props.onPointerMove(event);
        }
        _verbose && console.log("onPointerMove", event);
    }
    onPointerUp(event) {
        delete this._activePointers[event.pointerId];
        const props = this.props;
        if (props.capture || this.capturePointer) {
            this.element.releasePointerCapture(event.pointerId);
        }
        if (props.onPointerUp) {
            props.onPointerUp(event);
        }
        _verbose && console.log("onPointerUp", event);
    }
    onPointerCancel(event) {
        delete this._activePointers[event.pointerId];
        const props = this.props;
        if (props.capture) {
            this.element.releasePointerCapture(event.pointerId);
        }
        if (props.onPointerCancel) {
            props.onPointerCancel(event);
        }
        _verbose && console.log("onPointerCancel", event);
    }
    onPointerEnter(event) {
        const props = this.props;
        if (props.onPointerEnter) {
            props.onPointerEnter(event);
        }
        _verbose && console.log("onPointerEnter", event);
    }
    onPointerLeave(event) {
        const props = this.props;
        if (props.onPointerLeave) {
            props.onPointerLeave(event);
        }
        _verbose && console.log("onPointerLeave", event);
    }
    onDoubleClick(event) {
    }
    onContextMenu(event) {
    }
}
exports.default = Pointable;
Pointable.defaultProps = {
    className: "ff-pointable"
};
//# sourceMappingURL=Pointable.js.map