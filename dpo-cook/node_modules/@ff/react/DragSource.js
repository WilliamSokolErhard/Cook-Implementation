"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2018 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const Draggable_1 = require("./Draggable");
const _dragSpriteStyle = {
    display: "block",
    position: "fixed",
    zIndex: 1000,
    pointerEvents: "none"
};
const DragSprite = function (props) {
    if (!props.active) {
        return null;
    }
    return (React.createElement("div", { ref: props.onSprite, style: _dragSpriteStyle }, props.children));
};
class DragSource extends Draggable_1.default {
    constructor(props) {
        super(props);
        this.spriteElement = null;
        this.dragTarget = null;
        this.dropTarget = null;
        this.payloadType = props.payloadType;
        this.payload = props.payload;
        this.spriteOffsetX = 0;
        this.spriteOffsetY = 0;
        this.onSprite = this.onSprite.bind(this);
    }
    render() {
        const { className, style, sprite, children } = this.props;
        const props = {
            className,
            style: Object.assign({}, style, { touchAction: "none" }),
            ref: this.element,
            "touch-action": "none",
            onPointerDown: this.onPointerDown,
            onPointerMove: this.onPointerMove,
            onPointerUp: this.onPointerUp,
            onDoubleClick: this.onDoubleClick,
            onContextMenu: this.onContextMenu
        };
        return (React.createElement("div", Object.assign({}, props),
            children,
            React.createElement(DragSprite, { active: this.state.isDragging, onSprite: this.onSprite }, sprite || children)));
    }
    onDragBegin(event) {
        this.initSprite(event);
        this.moveSprite(event);
        this.dragTarget = null;
        this.dropTarget = null;
        if (this.props.onDragBegin) {
            const dragEvent = this.createPointerDragEvent(event);
            this.props.onDragBegin(dragEvent);
            this.payloadType = dragEvent.payloadType;
            this.payload = dragEvent.payload;
        }
    }
    onDragMove(event, dx, dy) {
        this.moveSprite(event);
        this.updateDropTarget(event);
        if (this.props.onDragMove) {
            this.props.onDragMove(this.createPointerDragEvent(event), dx, dy);
        }
    }
    onDragEnd(event) {
        if (this.dropTarget) {
            let dropEvent = new CustomEvent("ff-drop", {
                detail: this.createPointerDragEvent(event)
            });
            this.dropTarget.dispatchEvent(dropEvent);
        }
        if (this.props.onDragEnd) {
            this.props.onDragEnd(this.createPointerDragEvent(event));
        }
        this.dragTarget = null;
        this.dropTarget = null;
    }
    onSprite(element) {
        this.spriteElement = element;
    }
    initSprite(event) {
        if (this.element.current) {
            const rect = this.element.current.getBoundingClientRect();
            this.spriteOffsetX = rect.left - event.clientX;
            this.spriteOffsetY = rect.top - event.clientY;
        }
    }
    moveSprite(event) {
        if (this.spriteElement) {
            this.spriteElement.style.left = (event.clientX + this.spriteOffsetX) + "px";
            this.spriteElement.style.top = (event.clientY + this.spriteOffsetY) + "px";
        }
    }
    updateDropTarget(event) {
        let targetChanged = false;
        const dragTarget = document.elementFromPoint(event.clientX, event.clientY);
        if (dragTarget !== this.dragTarget) {
            this.dragTarget = dragTarget;
            let dropTarget = null;
            if (dragTarget) {
                // dispatch probe event to test if it gets caught while bubbling
                const dragEvent = this.createPointerDragEvent(event);
                dragEvent.dropTarget = null;
                const probeEvent = new CustomEvent("ff-dragprobe", {
                    detail: dragEvent,
                    bubbles: true
                });
                dragTarget.dispatchEvent(probeEvent);
                dropTarget = dragEvent.dropTarget;
            }
            if (dropTarget !== this.dropTarget) {
                targetChanged = true;
                if (this.dropTarget) {
                    const leaveEvent = new CustomEvent("ff-dragleave", {
                        detail: this.createPointerDragEvent(event)
                    });
                    this.dropTarget.dispatchEvent(leaveEvent);
                }
                this.dropTarget = dropTarget;
                if (this.dropTarget) {
                    const enterEvent = new CustomEvent("ff-dragenter", {
                        detail: this.createPointerDragEvent(event)
                    });
                    this.dropTarget.dispatchEvent(enterEvent);
                }
            }
        }
        if (!targetChanged && this.dropTarget) {
            const updateEvent = new CustomEvent("ff-dragupdate", {
                detail: this.createPointerDragEvent(event)
            });
            this.dropTarget.dispatchEvent(updateEvent);
        }
    }
    createPointerDragEvent(event) {
        let dragEvent = Object.assign({}, event);
        dragEvent.payloadType = this.payloadType;
        dragEvent.payload = this.payload;
        dragEvent.dragSource = this;
        dragEvent.dropTarget = this.dropTarget;
        return dragEvent;
    }
}
exports.default = DragSource;
DragSource.defaultProps = {
    className: "ff-drag-source",
    payloadType: "",
    payload: undefined
};
//# sourceMappingURL=DragSource.js.map