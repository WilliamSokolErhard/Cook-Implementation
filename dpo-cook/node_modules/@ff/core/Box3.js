"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Vector3_1 = require("./Vector3");
class Box3 {
    constructor(minX, minY, minZ, maxX, maxY, maxZ) {
        this.min = new Vector3_1.default(minX, minY, minZ);
        this.max = new Vector3_1.default(maxX, maxY, maxZ);
    }
    set(minX, minY, minZ, maxX, maxY, maxZ) {
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setEmpty() {
        this.min.set(Infinity, Infinity, Infinity);
        this.max.set(-Infinity, -Infinity, -Infinity);
        return this;
    }
    isEmpty() {
        return !(isFinite(this.max.x - this.min.x)
            && isFinite(this.max.y - this.min.y)
            && isFinite(this.max.z - this.min.z));
    }
    uniteWith(other) {
        const p0 = this.min, p1 = this.max;
        p0.set(Math.min(p0.x, other.min.x), Math.min(p0.y, other.min.y), Math.min(p0.z, other.min.z));
        p1.set(Math.max(p1.x, other.max.x), Math.max(p1.y, other.max.y), Math.max(p1.z, other.max.z));
        return this;
    }
    intersectWith(other) {
        const min = this.min, max = this.max;
        min.set(Math.max(min.x, other.min.x), Math.max(min.y, other.min.y), Math.max(min.z, other.min.z));
        max.set(Math.min(max.x, other.max.x), Math.min(max.y, other.max.y), Math.min(max.z, other.max.z));
        return this;
    }
    include(x, y, z) {
        const min = this.min, max = this.max;
        min.x = Math.min(min.x, x);
        min.y = Math.min(min.y, y);
        min.z = Math.min(min.z, z);
        max.x = Math.max(max.x, x);
        max.y = Math.max(max.y, y);
        max.z = Math.max(max.z, z);
        return this;
    }
    includePoint(point) {
        const min = this.min, max = this.max;
        min.x = Math.min(min.x, point.x);
        min.y = Math.min(min.y, point.y);
        min.z = Math.min(min.z, point.z);
        max.x = Math.max(max.x, point.x);
        max.y = Math.max(max.y, point.y);
        max.z = Math.max(max.z, point.z);
        return this;
    }
    normalize() {
        const min = this.min, max = this.max;
        if (min.x > max.x) {
            const t = min.x;
            min.x = max.x;
            max.x = t;
        }
        if (min.y > max.y) {
            const t = min.y;
            min.y = max.y;
            max.y = t;
        }
        if (min.z > max.z) {
            const t = min.z;
            min.z = max.z;
            max.z = t;
        }
        return this;
    }
}
exports.default = Box3;
//# sourceMappingURL=Box3.js.map