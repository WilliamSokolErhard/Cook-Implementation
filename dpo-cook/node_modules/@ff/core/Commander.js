"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Publisher_1 = require("./Publisher");
const Command_1 = require("./Command");
class Commander extends Publisher_1.default {
    constructor(capacity) {
        super();
        this.addEvent("update");
        this.stack = [];
        this.pointer = -1;
        this.capacity = capacity !== undefined ? capacity : Commander.defaultCapacity;
    }
    register(propsOrFactory) {
        let factory;
        if (typeof propsOrFactory === "function") {
            factory = propsOrFactory;
        }
        else {
            factory = (args) => new Command_1.default(args, propsOrFactory);
        }
        const action = (...args) => {
            const command = factory(args);
            this.do(command);
        };
        return action;
    }
    setCapacity(capacity) {
        this.capacity = capacity;
        while (this.stack.length > capacity) {
            this.stack.shift();
            this.pointer--;
        }
        if (this.pointer < 0) {
            this.stack = [];
            this.pointer = -1;
        }
    }
    do(command) {
        console.log(`Commander.do - '${command.name}'`);
        command.do();
        if (command.canUndo()) {
            this.stack.splice(this.pointer + 1);
            this.stack.push(command);
            if (this.stack.length > this.capacity) {
                this.stack.shift();
            }
            this.pointer = this.stack.length - 1;
            this.emit("update");
        }
    }
    undo() {
        if (this.pointer >= 0) {
            const command = this.stack[this.pointer];
            command.undo();
            this.pointer--;
            this.emit("update");
        }
    }
    redo() {
        if (this.pointer < this.stack.length - 1) {
            this.pointer++;
            const command = this.stack[this.pointer];
            command.do();
            this.emit("update");
        }
    }
    clear() {
        if (this.stack.length > 0) {
            this.stack = [];
            this.pointer = -1;
            this.emit("update");
        }
    }
    canUndo() {
        return this.pointer >= 0;
    }
    canRedo() {
        return this.pointer < this.stack.length - 1;
    }
    getUndoText() {
        if (this.pointer >= 0) {
            return "Undo " + this.stack[this.pointer].name;
        }
        return "Can't Undo";
    }
    getRedoText() {
        if (this.pointer < this.stack.length - 1) {
            return "Redo " + this.stack[this.pointer + 1].name;
        }
        return "Can't Redo";
    }
}
exports.default = Commander;
Commander.defaultCapacity = 30;
//# sourceMappingURL=Commander.js.map