"use strict";
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SortedArray_1 = require("./SortedArray");
/**
 * Base class for a track containing keyframes
 */
class AnimationTrack {
    constructor() {
        this.keys = new SortedArray_1.default();
        this.defaultValue = null;
        this.changed = true;
    }
    get length() {
        return this.keys.items.length;
    }
    empty() {
        return this.keys.empty();
    }
    setDefaultValue(value) {
        this.defaultValue = value;
    }
    insert(time, value) {
        this.insertKey({ time, value });
    }
    insertKey(key) {
        this.changed = true;
        this.keys.insertAt(key.time, key);
    }
    removeKey(key) {
        this.changed = true;
        return this.keys.removeAt(key.time);
    }
    removeKeyAt(time) {
        this.changed = true;
        return this.keys.removeAt(time);
    }
    valueAt(time) {
        const keys = this.keys;
        if (!keys.items.length) {
            return this.defaultValue;
        }
        const index = keys.indexAtBefore(time);
        const item = keys.items[index > 0 ? index : 0];
        return item ? item.value.value : this.defaultValue;
    }
    keysAround(time, result) {
        const keys = this.keys;
        const index = keys.indexAtBefore(time);
        result = result || { left: null, right: null };
        const next = keys.items[index + 1];
        result.right = next ? next.value : null;
        result.left = index > -1 ? keys.items[index].value : null;
        return result;
    }
    leftKey(time) {
        const keys = this.keys;
        const index = keys.indexAtBefore(time);
        const item = index > -1 ? keys.items[index] : null;
        return item ? item.value : null;
    }
}
exports.default = AnimationTrack;
//# sourceMappingURL=AnimationTrack.js.map